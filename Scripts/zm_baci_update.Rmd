---
title: "zm_baci_update"
author: "Denver Link"
date: "2024-12-11"
output: html_document
editor_options: 
  chunk_output_type: console
---

# Things to do:
1. decide which level of lag we would want for the analysis 
2. finish analysis loop that auto populates figures, tables, summaries

# Library
```{r}
library(tidyverse)
library(mwlaxeref)
library(janitor)
library(mnsentinellakes)
library(sf)
library(brms)
library(emmeans)
library(tidybayes)
library(patchwork)
library(cowplot)
library(ggpubr)
library(sf)
library(tigris)
library(ggspatial)
```

# Data
```{r}
#mercury data
hg <- read_csv(file.path("G:", "Shared drives", "Hansen Lab", "RESEARCH PROJECTS", "Statewide mercury modeling", "Data", "Mercury Data", "allfish_data_04042024_JLO.csv")) %>% 
  filter(!(is.na(LGTHIN) | is.na(HGPPM) | is.na(DOWID))) %>%   #removes samples with no hg, length, or dow data
  filter(TYPE %in% c("Lake", "LAKE")) %>% 
  mutate(DOWID = fixlakeid(DOWID)) %>% 
  filter(DOWID != "16000100") %>% 
  local_to_nhdhr(from_colname = "DOWID", states = "mn") %>% 
  mutate(nhdhr.id = str_remove(nhdhr.id, "nhdhr_")) %>% 
  select(SAMPLENO,
         WATERWAY,
         TYPE,
         LOCATION,
         DOWID,
         nhdhr.id,
         DATECOL2,
         YEARCOLL,
         SPEC,
         ANATHG,
         NOFISH,
         LGTHIN,
         WTLB,
         AGE,
         SEX,
         HGPPM,
         HGCODE,
         HGLAB,
         HGCMMT) %>% 
  rename(DOW = DOWID,
         nhdid = nhdhr.id) %>% 
  ungroup()

#connection to covariates
dnr_covary <- read_csv(file.path("G:", "Shared drives", "Hansen Lab", "RESEARCH PROJECTS", "Statewide mercury modeling", "Data", "Covariate Data", "MN_lakes_watershed_lulc_fromDNR.csv")) %>% 
  mutate(logit_wetlands = car::logit(Percent_Wetland),
         logit_urban = car::logit(Percent_Urban),
         logit_ag = car::logit(Percent_Cultivated_Crops),
         log_WS_Lake_Ratio = log(WS_Lake_Ratio))

#scaled_dnr <- dnr_covary %>%
  #mutate_at(vars(Total_Pasture_Hay_Hectares:log_WS_Lake_Ratio), scale) %>% 
  #rename_with(~ paste0("scaled_", .), Total_Pasture_Hay_Hectares:log_WS_Lake_Ratio) 

#dnr_covary <- dnr_covary %>% 
  #left_join(scaled_dnr)

#adding dnr covariates into the data
hg <- hg %>% 
  left_join(dnr_covary)
rm(dnr_covary, scaled_dnr)

#glm - for clarity and area values
glm <- read_csv(file.path("G:", "Shared drives", "Hansen Lab", "RESEARCH PROJECTS", "Statewide mercury modeling", "Data", "Covariate Data", "glm_lake_metadata.csv")) %>%
  filter(state == "MN") %>% 
  rename(nhdid = site_id) %>% 
  mutate(nhdid = gsub("^nhdhr_", "", nhdid)) %>% 
  mutate(clarity = case_when(is.infinite(clarity) ~ NA,
                             TRUE ~ clarity)) %>% 
  mutate(log_area = log(area))


hg <- hg %>% 
  left_join(glm) %>% 
  mutate(across(starts_with("scaled_"), as.vector))
rm(glm)
glimpse(hg)

#infested waters list
zm <- read_csv("Data/ZM_MN_NHD.csv") %>% 
  filter(!is.na(DOW)) %>% 
  mutate(DOW = as.character(gsub("mndow_", "", MNDOW_ID)),
         nhdid = NHD_ID) %>% 
  select(DOW,
         Year_Infested)

hg <- hg %>% 
  left_join(zm, by = c("DOW"))
rm(zm)

#lake link
lake_link <- read_csv("Data/lake_link.csv") %>% 
  distinct(lake_nhdid, .keep_all = T) %>% 
  rename(nhdid = lake_nhdid)

lake_link_sf <- lake_link %>% 
  st_as_sf(coords = c("lake_lon_decdeg", "lake_lat_decdeg"), crs = 4326) %>% 
  st_transform(crs = 32615)
utm_coords <- st_coordinates(lake_link_sf)
lake_link <- lake_link %>%
  mutate(easting = utm_coords[, 1]/1000,
         northing = utm_coords[, 2]/1000)
#utm values in km instead of m
rm(lake_link_sf, utm_coords)

hg <- hg %>% 
  left_join(lake_link)
rm(lake_link)


#data for modeling - select for columns of use 
hg.model <- hg %>%
  select(WATERWAY,
         TYPE,
         DOW,
         nhdid,
         DATECOL2,
         YEARCOLL,
         SPEC,
         ANATHG,
         NOFISH,
         LGTHIN,
         HGPPM,
         HGCODE,
         Total_Wetland_Hectares,
         Percent_Wetland,
         Percent_Urban,
         Percent_Cultivated_Crops,
         logit_wetlands,
         logit_urban,
         logit_ag,
         WS_Lake_Ratio,
         log_WS_Lake_Ratio,
         centroid_lat,
         centroid_lon,
         max_depth,
         area,
         log_area,
         elevation,
         clarity,
         Year_Infested,
         lake_lat_decdeg,
         lake_lon_decdeg,
         easting,
         northing) %>% 
  mutate(zm_infested_lag_1 = Year_Infested +1,
         zm_infested_lag_2 = Year_Infested +2,
         zm_infested_lag_3 = Year_Infested +3,
         zm_infested_lag_4 = Year_Infested +4,
         zm_infested_lag_5 = Year_Infested +5,
         zm_lake = case_when(is.na(Year_Infested) ~ "n",
                             TRUE ~ "y"),
         zm_sample = case_when(Year_Infested <=YEARCOLL ~ "y",
                               TRUE ~ "n"),
         zm_sample_lag_1 = case_when(zm_infested_lag_1 <= YEARCOLL ~ "y",
                               TRUE ~ "n"),
         zm_sample_lag_2 = case_when(zm_infested_lag_2 <= YEARCOLL ~ "y",
                               TRUE ~ "n"),
         zm_sample_lag_3 = case_when(zm_infested_lag_3 <= YEARCOLL ~ "y",
                               TRUE ~ "n"),
         zm_sample_lag_4 = case_when(zm_infested_lag_4 <= YEARCOLL ~ "y",
                               TRUE ~ "n"),
         zm_sample_lag_5 = case_when(zm_infested_lag_5 <= YEARCOLL ~ "y",
                               TRUE ~ "n"),
         time_since_invasion = YEARCOLL - Year_Infested) %>% 
  clean_names()

rm(hg)
```

# Data Coverage - pre BACI filtering
```{r}
# zebra mussel coverage
hg.model %>% 
  group_by(zm_lake) %>% 
  summarise(total_samples = n(),
            pre_zm = sum(zm_sample == "n"),
            post_zm = sum(zm_sample == "y"),
            distinct_lakes = n_distinct(dow),
            distinct_years = n_distinct(yearcoll))

#how many zm samples and lakes in 2023?
hg.model %>% 
  filter(zm_lake == "y" & yearcoll == "2023") %>% 
  summarise(zm_sampling_2023 = n(),
            zm_sampling_lakes_2023 = n_distinct(dow)
  )

#how many zebra mussel lakes have post data - how many years of post?
hg.model %>% 
  filter(zm_lake == "y") %>% 
  distinct(dow, zm_sample) %>% 
  group_by(dow) %>% 
  count() %>% 
  filter(n > 1)

hg.model %>% 
  filter(zm_lake == "y" & zm_sample == "y") %>% 
  group_by(dow) %>% 
  summarise(n_years = n_distinct(yearcoll)) %>% 
  ggplot() +
  geom_histogram(aes(x = n_years)) +
  geom_histogram(data = . %>% filter(dow == "48000200"), aes(n_years, fill = "red"))+
  theme(legend.position = "none")

#for lakes sampled in 2023 - how many years of post data do they have?
lakes_2023 <- hg.model %>% 
  filter(yearcoll == 2023 & zm_lake == "y") %>% 
  distinct(dow, waterway, year_infested)

hg.model %>% 
  filter(dow %in% c(lakes_2023$dow)) %>% 
  filter(zm_sample == "y") %>% 
  group_by(dow) %>% 
  summarise(n_years = n_distinct(yearcoll)) %>% 
  ggplot() +
  geom_histogram(aes(n_years))
# 8/18 zebra mussel lake sampled in 2023 were sampled for the first time
rm(lakes_2023)

#would we loose any data with zm-post lag
hg.model %>%
  pivot_longer(cols = starts_with("zm_sample"), 
               names_to = "scenario", 
               values_to = "status") %>%
  filter(status == "y") %>% 
  group_by(scenario, status) %>%
  summarize(distinct_lakes = n_distinct(dow), .groups = "drop")
#looks like we would loose 8 lakes with a one year lag and 21 lakes with a two year lag

hg.model %>% 
  mutate(zm_sample_1_year = case_when(time_since_invasion >= 1 ~ "y", TRUE ~ "n"),
         zm_sample_2_year = case_when(time_since_invasion >= 2 ~ "y", TRUE ~ "n")) %>% 
   pivot_longer(cols = starts_with("zm_sample"), 
               names_to = "scenario", 
               values_to = "status") %>%
  filter(status == "y") %>% 
  group_by(scenario, status) %>%
  summarize(distinct_lakes = n_distinct(dow), .groups = "drop")

lag_lakes <- hg.model %>% 
  filter(time_since_invasion >= 2) %>% 
  distinct(dow)

normal_lakes <- hg.model %>% 
  filter(time_since_invasion >= 0) %>% 
  distinct(dow)

lost_lakes <- anti_join(normal_lakes, lag_lakes) %>% 
  left_join(hg.model, by = "dow")
#1054 samples
#this is a note more for Denver than anything else: at first I filtered for samples that had a y for zm_sample and a n for zm_sample_lag_2 to find distinct lakes that we would loose with a lag year but I was getting more lakes that were expected. This was because that call gets lakes that were sampled within the lag period AND after the lag period  - the anti join above is representative of the lakes we would loose with a two year lag

lost_lakes %>% 
  group_by(zm_sample, zm_sample_lag_2) %>% 
  count() 

lost_lakes %>% 
  group_by(waterway) %>% 
  count() %>% 
  print(n = nrow(.))

hg.model %>% 
  filter(dow == "27003100") %>% 
  group_by(waterway, yearcoll, year_infested, spec) %>% 
  count() %>% 
  print(n = nrow(.))
#strange that bde doesn't get more sampling effort 
rm(lag_lakes, lost_lakes)

#specific to walleye
hg.model %>% 
  filter(spec == "WAE") %>% 
  mutate(zm_sample_1_year = case_when(time_since_invasion >= 1 ~ "y", TRUE ~ "n"),
         zm_sample_2_year = case_when(time_since_invasion >= 2 ~ "y", TRUE ~ "n")) %>% 
   pivot_longer(cols = starts_with("zm_sample"), 
               names_to = "scenario", 
               values_to = "status") %>%
  filter(status == "y") %>% 
  group_by(scenario, status) %>%
  summarize(distinct_lakes = n_distinct(dow), .groups = "drop")

hg.model %>% 
  filter(spec == "NOP") %>% 
  mutate(zm_sample_1_year = case_when(time_since_invasion >= 1 ~ "y", TRUE ~ "n"),
         zm_sample_2_year = case_when(time_since_invasion >= 2 ~ "y", TRUE ~ "n")) %>% 
   pivot_longer(cols = starts_with("zm_sample"), 
               names_to = "scenario", 
               values_to = "status") %>%
  filter(status == "y") %>% 
  group_by(scenario, status) %>%
  summarize(distinct_lakes = n_distinct(dow), .groups = "drop")

#for lakes sampled in 2023 - how many lakes have an invasion year of 2021 or 2022, making them not conducive to a lag?
hg.model %>% 
  filter(spec %in% c("WAE", "NOP") & yearcoll == "2023") %>% 
  distinct(dow, year_infested) %>% 
  summarise(yearcoll_2021 = sum(year_infested == "2021", na.rm = T),
            yearcoll_2022 = sum(year_infested == "2022", na.rm = T),
            yearcoll_2023 = sum(year_infested == "2023", na.rm = T))
#this tells us that all of the zebra mussel lakes sampled in 2023 have enough lag time since invasion to be considered 

rm(normal_lakes)


```

#BACI filter function
1. We filter out fish below 5" and cut LOD samples in half
2. Filter function - this filter function takes 1.) the species of interest, 2.) the data and 3.) the lag year variable (y/n) and returns a dataset that has lakes with a least one year of data pre and one year of data post. ZM invasion year is determined the the lag year variable pre filtering and the reference invasion lakes are determined by the closest invaded lake within the analysis
3. There is code to get individual calls (providing just one specie and zm_lag_year) AND there is code to loop over every combo of WAE and NOP for 6 year of ZM Y/N
*I did a quick fix for lagging the reference lake year to match zm lake, consider in the future making it automated*
```{r}
#pre lake grouping filtering (removing small fish and dealing with fish @ the LOD)
hg.model <- hg.model %>% 
  filter(lgthin >= 5) %>% 
  mutate(hgppm = case_when(hgcode == "K" ~ hgppm/2,
                           TRUE ~ hgppm))

create_species_data <- function(species, data, lag_variable) {
  # Filter zebra mussel lakes
  zm_lakes <- data %>% 
    filter(spec == species) %>% 
    filter(yearcoll >= 2000) %>% 
    filter(zm_lake == "y") %>% 
    distinct(dow, !!sym(lag_variable)) %>% 
    group_by(dow) %>% 
    count() %>% 
    filter(n > 1)
  
  zm_lakes <- data %>% 
    filter(dow %in% zm_lakes$dow) %>% 
    distinct(dow, year_infested, centroid_lat, centroid_lon) %>% 
    st_as_sf(coords = c("centroid_lon", "centroid_lat"), crs = 4326)

  # Filter reference lakes
  ref_lakes <- data %>% 
    filter(spec == species) %>% 
    filter(yearcoll >= 2000) %>% 
    filter(zm_lake == "n") %>% 
    filter(!is.na(centroid_lon)) %>% 
    st_as_sf(coords = c("centroid_lon", "centroid_lat"), crs = 4326)
  
  #taking the year invaded with 2 years of lag to build reference systems - change as needed for decided lag time
  ref_lakes <- ref_lakes %>% 
    mutate(nearest_zm_lake = st_nearest_feature(geometry, zm_lakes$geometry),
           nearest_infested_year = zm_lakes$year_infested[nearest_zm_lake],
           !!sym(lag_variable) := case_when(yearcoll >= (nearest_infested_year +2)  ~ "y",
                                       yearcoll <= (nearest_infested_year +2) ~ "n")) %>% 
    distinct(dow, !!sym(lag_variable)) %>% 
    group_by(dow) %>% 
    count() %>% 
    filter(n >1)
  
############this section does not filter - makes a map of connections##########
mn_map <- states(cb = T) %>% 
  filter(STUSPS == "MN")

minnesota_sf <- st_as_sf(mn_map)
rm(mn_map)
  
ref_lakes_all <- data %>% 
    filter(spec == species) %>% 
    filter(yearcoll >= 2000) %>% 
    filter(zm_lake == "n") %>% 
    filter(!is.na(centroid_lon)) %>% 
    st_as_sf(coords = c("centroid_lon", "centroid_lat"), crs = 4326) %>% 
  distinct(dow, geometry)

lines <- ref_lakes %>%
  inner_join(ref_lakes_all, by = c("dow")) %>% 
  mutate(
        nearest_zm_geometry = zm_lakes$geometry[st_nearest_feature(geometry, zm_lakes$geometry)]
    ) %>%
    rowwise() %>%
    mutate(
        line_geometry = st_sfc(st_cast(st_union(geometry, nearest_zm_geometry), "LINESTRING"))
    ) %>%
    ungroup() %>%
    st_as_sf()

map_data <- list(
    ref_lakes = ref_lakes,
    zm_lakes = zm_lakes,
    lines = lines
)

map <- ggplot() +
  geom_sf(data = minnesota_sf, fill = "white", color = "black") +
    geom_sf(data = map_data$lines$geometry, aes(color = "Reference Lakes"), size = 3) +
    geom_sf(data = map_data$zm_lakes, aes(color = "ZM Lakes"), size = 3, shape = 17) +
    geom_sf(data = map_data$lines, aes(geometry = line_geometry, color = "Connections"), linetype = "dashed", size = 0.8) +
    scale_color_manual(
        values = c("Reference Lakes" = "lightblue", "ZM Lakes" = "salmon", "Connections" = "black"),
        name = ""
    ) +
  labs(title = paste(species, lag_variable)) +
    theme_minimal()  +
  theme(legend.position = "bottom")
rm(lines, map_data, ref_lakes_all)
##############################################################################
  
  zm_fish <- data %>% 
    filter(yearcoll >= 2000) %>%
    filter(spec == species) %>% 
    filter(dow %in% c(zm_lakes$dow)) %>% 
    mutate(centroid_lon_orig = centroid_lon,
           centroid_lat_orig = centroid_lat) 

#taking the year invaded with 2 years of lag to build reference systems
  ref_fish <- data %>% 
    filter(yearcoll >= 2000) %>% 
    filter(spec == species) %>% 
    filter(!is.na(centroid_lon)) %>% 
    mutate(centroid_lon_orig = centroid_lon,
           centroid_lat_orig = centroid_lat) %>% 
    st_as_sf(coords = c("centroid_lon", "centroid_lat"), crs = 4326) %>% 
    filter(dow %in% c(ref_lakes$dow)) %>% 
    mutate(nearest_zm_lake = st_nearest_feature(geometry, zm_lakes$geometry),
           nearest_infested_year = zm_lakes$year_infested[nearest_zm_lake],
           !!sym(lag_variable) := case_when(yearcoll >= (nearest_infested_year + 2)  ~ "y",
                                       yearcoll <= (nearest_infested_year + 2) ~ "n"))  

  # Combine zebra mussel and reference data
  species_data <- bind_rows(ref_fish, zm_fish) %>% 
    st_drop_geometry() %>% 
    mutate(centroid_lat = centroid_lat_orig,
           centroid_lon = centroid_lon_orig) 
    

  # Scale length
   # Scale length
  species_data <- species_data %>% 
    mutate(scaled_length = c(scale(lgthin))) %>% 
    select(waterway,
           dow,
           centroid_lat,
           centroid_lon,
           type,
           yearcoll,
           spec,
           anathg,
           lgthin,
           scaled_length,
           hgppm,
           zm_lake,
           !!sym(lag_variable)
           )
  print(map)
  return(species_data)
}

#example of how to get one species and lag year
wae_data <- create_species_data(species = "WAE", data = hg.model, lag_variable = "zm_sample_lag_2")
nop_data <- create_species_data(species = "NOP", data = hg.model, lag_variable = "zm_sample_lag_2")

#loop over all combos of NOP and WAE zm_sample to zm_sample_lag_year_5
species <- c("WAE", "NOP")
lag_variables <- c("zm_sample", paste0("zm_sample_lag_", 1:5))

for (species in species) {
  for (lag_var in lag_variables) {
    # Create the data for the current combination
    species_data <- create_species_data(species = species, data = hg.model, lag_variable = lag_var)
    
    # Dynamically assign the object name
    object_name <- paste0(species, "_", lag_var)
    assign(object_name, species_data)
  }
}
```

#Summary Stats - lag year of 2 on ZM and Ref with matching
```{r}
#stats for the singular model run of 2 lag years ref and zm with matching
combined_data <- bind_rows(nop_data, wae_data)

lakes <- combined_data %>% 
  group_by(spec, zm_lake, zm_sample_lag_2) %>% 
  summarise(n_lakes = n_distinct(dow),
            n_years = n_distinct(yearcoll),
            n_samples = n()) %>% 
  print(n = nrow(.))
write_csv(lakes, "baci_lake_stats.csv")
rm(lakes)


fish <- combined_data %>% 
  group_by(spec, zm_lake, zm_sample_lag_2) %>% 
  summarise(mean = mean(lgthin),
            sd = sd(lgthin),
            min = min(lgthin),
            max = max(lgthin),
            n = n()) %>% 
  print(n = nrow(.))
write_csv(fish, "baci_fish_pre_post_stats.csv")
rm(fish)

fish <- combined_data %>% 
  group_by(spec, zm_lake) %>% 
  summarise(mean = mean(lgthin),
            sd = sd(lgthin),
            min = min(lgthin),
            max = max(lgthin),
            n = n())
write_csv(fish, "baci_fish_invasion_stats.csv")
rm(fish)

fish <- combined_data %>% 
  group_by(spec) %>% 
  summarise(mean = mean(lgthin),
            sd = sd(lgthin),
            min = min(lgthin),
            max = max(lgthin),
            n_lakes = n_distinct(dow),
            n = n())
write_csv(fish, "baci_fish_spec_stats.csv")
rm(fish)
```

#Summary Stats - looping over zm lag year with matching - ref lag does not change
```{r}
# List of all dynamically created objects
species <- c("WAE", "NOP")
data_list <- mget(ls(pattern = paste0("^(", paste(species, collapse = "|"), ")_zm_sample.*")))

# Add a column for lag year by extracting it from the object name
combined_data <- bind_rows(lapply(names(data_list), function(name) {
  data <- data_list[[name]]
  
  # Extract lag year
  lag_year <- sub(".*_lag_(\\d+)$", "\\1", name) # Extract lag year
  lag_year <- ifelse(grepl("lag", name), as.numeric(lag_year), 0) # Set to 0 if not lagged
  
  # Standardize zm_sample column
  if (lag_year == 0) {
    data$zm_sample_standardized <- data$zm_sample
  } else {
    lag_col_name <- paste0("zm_sample_lag_", lag_year)
    if (lag_col_name %in% colnames(data)) {
      data$zm_sample_standardized <- data[[lag_col_name]]
    } else {
      data$zm_sample_standardized <- NA # Handle cases where the lag column doesn't exist
    }
  }
  
  # Add lag year column
  data$lag_year <- lag_year
  
  return(data)
}))


combined_data %>% 
  group_by(spec, zm_lake, zm_sample_standardized, lag_year) %>% 
  summarise(n_lakes = n_distinct(dow),
            n_years = n_distinct(yearcoll),
            n_samples = n()) %>% 
  print(n = nrow(.))

combined_data %>% 
  group_by(spec, zm_lake, lag_year) %>%
  summarise(n_years = n_distinct(yearcoll)) %>% 
  print(n = nrow(.))

combined_data %>% 
  group_by(spec, zm_lake, zm_sample_standardized, lag_year) %>% 
  summarise(mean = mean(lgthin),
            sd = sd(lgthin),
            min = min(lgthin),
            max = max(lgthin),
            n = n()) %>% 
  print(n = nrow(.))

combined_data %>% 
  group_by(spec, zm_lake, lag_year) %>% 
  summarise(mean = mean(lgthin),
            sd = sd(lgthin),
            min = min(lgthin),
            max = max(lgthin),
            n = n())

combined_data %>% 
  group_by(spec, lag_year) %>% 
  summarise(mean = mean(lgthin),
            sd = sd(lgthin),
            min = min(lgthin),
            max = max(lgthin),
            n = n())


#how many samples were from mille lacs?
mille_lacs <- combined_data %>% 
  group_by(spec,  lag_year) %>% 
  summarise(total_sample = n(),
            total_zm_samples = sum(zm_lake == "y"),
            total_zm_post_samples = sum(zm_lake == "y" & zm_sample_standardized == "y"),
            mille_lacs_samples = sum(dow == "48000200"),
            mille_lacs_pre = sum(dow == "48000200" & zm_sample_standardized == "n"),
            mille_lacs_invaded_samples = sum(dow == "48000200" & zm_sample_standardized == "y"),
            total_prop_lacs = mille_lacs_samples/total_sample,
            zm_lakes_prop_lac = mille_lacs_invaded_samples/total_zm_samples,
            zm_lakes_post_prop_lacs = mille_lacs_invaded_samples/total_zm_post_samples) %>% 
  arrange(spec, lag_year) 

#how balanced is mille lacs?
combined_data %>% 
  filter(dow == "48000200") %>% 
  group_by(spec, lag_year) %>% 
  summarise(n_pre = sum(zm_sample_standardized == "n"),
            n_post = sum(zm_sample_standardized == "y")) %>% 
  arrange(spec, lag_year) %>% 
  print(n = nrow(.))

#just post samples
mille_lacs %>% 
  ggplot() +
  geom_col(aes(x = lag_year, y = zm_lakes_post_prop_lacs, fill = lag_year)) +
  theme_classic() +
  theme(legend.position = "none") +
  facet_wrap(~spec)

#total samples
mille_lacs %>% 
  ggplot() +
  geom_col(aes(x = lag_year, y = total_prop_lacs, fill = lag_year)) +
  theme_classic() +
  theme(legend.position = "none") +
  facet_wrap(~spec)

#number of unique lakes 
combined_data %>% 
  distinct(dow, zm_lake, spec, lag_year) %>% 
  group_by(lag_year, spec, zm_lake) %>% 
  summarise(n_lakes = n_distinct(dow)) %>% 
  ggplot() +
  geom_col(aes(x = lag_year, y = n_lakes, fill = lag_year)) +
  theme_classic() +
  theme(legend.position = "none") +
  facet_grid(spec ~ zm_lake, scales = "free")

combined_data %>% 
  distinct(dow, zm_lake, spec, lag_year) %>% 
  group_by(lag_year, spec, zm_lake) %>% 
  summarise(n_lakes = n_distinct(dow),
            prop_lakes = 1/n_lakes) %>% 
  ggplot() +
  geom_col(aes(x = lag_year, y = prop_lakes, fill = lag_year)) +
  theme_classic() +
  theme(legend.position = "none") +
  facet_grid(spec ~ zm_lake, scales = "free")
#so mille lacs makes ~10% of the post invasion samples 
rm(mille_lacs)
```

#Map - lag year 2 on ZM and Ref with matching
```{r}
combined_data <- bind_rows(nop_data, wae_data)

#make sf objects
lakes_sf <- st_as_sf(combined_data, coords = c("centroid_lon", "centroid_lat"), crs = 4326)

mn_map <- states(cb = T) %>% 
  filter(STUSPS == "MN")

minnesota_sf <- st_as_sf(mn_map)
rm(mn_map)

#summarize some data
lake_summary <- combined_data %>%
  group_by(dow, spec) %>%
  summarize(
    distinct_years = n_distinct(yearcoll),
    total_samples = n()
  )


spec <- combined_data %>% 
  distinct(dow, spec) %>% 
  pivot_wider(names_from = spec,
              values_from = spec,
              values_fn = length,
              values_fill = list(spec = NA)) %>% 
  mutate(species = case_when(NOP == "1" & WAE == "1" ~ "Walleye & Northern Pike",
                          NOP == "1" & is.na(WAE) ~ "Northern Pike",
                          TRUE ~ "Walleye"))

lakes_sf <- lakes_sf %>%
  left_join(lake_summary, by = c("dow", "spec")) %>% 
  left_join(spec) %>% 
  mutate(species_simp = species) %>% 
  mutate(species = case_when(species == "Walleye & Northern Pike" & spec == "WAE" ~ "Both - Walleye",
                             species == "Walleye & Northern Pike" & spec == "NOP" ~ "Both - Northern Pike",
                             species == "Northern Pike" ~ "Northern Pike",
                             species == "Walleye" ~ "Walleye"))

#simple map showing lake locations by species 
ggplot() +
  # Plot Minnesota state
  geom_sf(data = minnesota_sf, fill = "white", color = "black") +
  
  # Plot lakes with centroids
  geom_sf(data = lakes_sf, 
          aes(color = zm_lake, 
              shape = species_simp),
          size = 3) +
  scale_color_manual("Invasion Status of Lake", values = c("lightblue", "salmon"), labels = c("Uninvaded", "Zebra Mussel")) +
  scale_shape_manual("Species Sampled", values = c(1, 3, 10)) +
  # Remove gridlines and set white background
  theme_minimal() +
  theme(panel.background = element_rect(fill = "white", color = NA),
        panel.grid = element_blank(),
        legend.position = c(.79, .4),
         legend.box.background = element_rect(color = "black", size = 0.5),
        legend.key.size = unit(.2, "cm")) +
  annotation_scale(location = "tl") +
  annotation_north_arrow(location = "br", which_north = "true")
ggsave("BACI_lakes_map.jpg", height = 7, width = 7, dpi = 600, bg = "white")

rm(lake_summary, lakes_sf, map_data, minnesota_sf, spec)
```

# Analysis 

1. example of running one model at a time - must change the invasion variables and data input
```{r}
#walleye model fit
fit_wae <- brm(log(hgppm) ~ scaled_length + zm_lake*zm_sample_lag_2 + (1|dow) + (1|yearcoll), 
             data = wae_data, 
             family = gaussian(), 
             iter = 20000,
             warmup = 5000)
#saveRDS(fit_wae, "baci_update_wae.rds")

#northern pike model fit
fit_nop <- brm(log(hgppm) ~ scaled_length + zm_lake*zm_sample_lag_2 + (1|dow) + (1|yearcoll), 
             data = nop_data, 
             family = gaussian(), 
             iter = 20000,
             warmup = 5000)
#saveRDS(fit_nop, "baci_update_nop.rds")
```

saved model runs
```{r}
fit_wae <- readRDS("Output/BACI/baci_update_wae.rds")
fit_nop <- readRDS("Output/BACI/baci_update_nop.rds")

summary(fit_wae)
summary(fit_nop)
```

2. looping over all NOP and WAE combos of zm_lag for sensitivity analysis 
```{r}
species <- c("WAE", "NOP")
lag_variables <- c("zm_sample", paste0("zm_sample_lag_", 1:5))

for (species in species) {
  for (lag_var in lag_variables) {
    # Get the dataset name dynamically
    data_name <- paste0(species, "_", lag_var)
    current_data <- get(data_name) # Get the dataset object dynamically
    
    # Define the formula dynamically
    model_formula <- as.formula(
      paste0("log(hgppm) ~ scaled_length + zm_lake * ", lag_var, " + (1|dow) + (1|yearcoll)")
    )
    
    # Fit the model
    fit <- brm(
      formula = model_formula,
      data = current_data,
      family = gaussian(),
      iter = 8000,
      warmup = 4000
    )
    
    # Save the model
    saveRDS(fit, paste0("baci_update_", tolower(species), "_", lag_var, ".rds"))
  }
}
```

#saved model runs
```{r}
species <- c("WAE", "NOP")
lag_variables <- c("zm_sample", paste0("zm_sample_lag_", 1:5))

# Initialize a list to store models
model_list <- list()

for (sp in species) {
  for (lag_var in lag_variables) {
    # Construct the file name
    file_name <- paste0("baci_update_", tolower(sp), "_", lag_var, ".rds")
    
    # Read the model
    fit <- readRDS(file_name)
    
    # Save to the list
    model_list[[paste(sp, lag_var, sep = "_")]] <- fit
  }
}
rm(fit, file_name, lag_var, lag_variables, sp, species)
```

# Sensitivity Anlsysis
Loops over emmeans for each model fit combo of NOP and WAE - creates marginal effects plot of every run for comparing
```{r}
#emmeans for each fit
marginal_draws_list <- list()

for (model_name in names(model_list)) {
  fit <- model_list[[model_name]]
  
  # Extract zm_sample variable dynamically
  zm_sample_var <- sub(".*_(zm_.*)", "\\1", model_name)
  
  # Generate marginal draws
  marg_draws <- emmeans(
    fit, 
    as.formula(paste("~ zm_lake *", zm_sample_var)),
    re_formula = NA, 
    epred = TRUE
  ) %>% 
    gather_emmeans_draws() %>% 
    mutate(hg_ppm = exp(.value))
  
  # Store results
  marginal_draws_list[[model_name]] <- marg_draws
}
rm(marg_draws, model_name, zm_sample_var)

#make contrasts 
contrasts_list <- list()

for (model_name in names(marginal_draws_list)) {
  marg_draws <- marginal_draws_list[[model_name]]
  
  zm_sample_var <- sub(".*_(zm_.*)", "\\1", model_name)
  
  # Compute contrasts
  contrasts_draws <- marg_draws %>% 
    select(-.chain, -.iteration) %>% 
    pivot_wider(names_from = c(zm_lake, all_of(zm_sample_var)),
                values_from = c(.value, hg_ppm)) %>%
    mutate(diff_reference = hg_ppm_n_y - hg_ppm_n_n,
           diff_zm = hg_ppm_y_y - hg_ppm_y_n) %>%
    select(.draw, diff_reference, diff_zm)
  
  # Store results
  contrasts_list[[model_name]] <- contrasts_draws
}
rm(contrasts_draws, model_name, zm_sample_var, marg_draws)

#plot
combined_contrasts <- contrasts_list %>%
  enframe(name = "model", value = "data") %>% # Convert list to a tibble
  unnest(data) %>%                           # Unpack each tibble in the list
  mutate(
    species = str_extract(model, "^[A-Z]+"),                 # Extract species
    model = str_remove(model, "^[A-Z]+_"),                  # Remove species from model
    lag = case_when(                                         # Extract lag info
      str_detect(model, "lag_\\d+") ~ str_extract(model, "lag_\\d+"),
      str_detect(model, "sample") ~ "sample",
      TRUE ~ NA_character_                                   # Catch any unexpected values
    ),
    lag = case_when(                                         # Clean up lag labels
      lag == "sample" ~ "Lag 0",
      !is.na(lag) ~ str_replace(lag, "lag_", "Lag "),
      TRUE ~ lag
    )
  )

  
combined_contrasts %>%
    pivot_longer(cols = c(diff_reference, diff_zm),
                 names_to = "zm_lake",
                 values_to = "diff") %>% 
    mutate(zm_lake = case_when(zm_lake == "diff_zm" ~ "Zebra Mussel",
                               TRUE ~ "Uninvaded")) %>% 
    ggplot() +
    stat_pointinterval(aes(x = zm_lake, y = diff, color = zm_lake), .width = c(.66, .95),
                       position = position_dodge(width = 0.5)) +
    geom_hline(yintercept = 0, linetype = "dashed") +
    ylab("Difference in Mercury\nConcentrations Before and After (ppm)") +
    xlab("") +
    scale_color_manual("Lake Status", values = c("lightblue", "salmon")) +
    facet_grid(species~lag, scales = "free_y") +
    theme_minimal() +
    theme(legend.position = "bottom",
          panel.grid.major.x = element_blank(),
          axis.text.x = element_blank())
ggsave("lag_zm_sensitvity_analysis.jpg", width = 7, height = 5, dpi = 600, background = "white")
```

###################all analysis below is based off singular model run##########


#Northern Pike Analysis
*2 lag years for both zm and reference lakes, matching invasion year to the nearest ZM lake for reference lakes
*products are included first in this chunk, all other explorations are below
```{r}
#############create data for plotting###############
#marginal effects based on specific length
length_stats <-  nop_data %>% 
  summarise(mean_length = mean(lgthin),
            sd_length = sd(lgthin))
specific_length_scaled <- (24 - length_stats$mean_length) / length_stats$sd_length

marg_draws <- emmeans(fit_nop, ~ zm_lake * zm_sample_lag_2, 
                      at = list(scaled_length = specific_length_scaled), 
                      re_fromula = NA, 
                      epred = T) %>% 
  gather_emmeans_draws() %>% 
  mutate(hg_ppm = exp(.value))

#working with marginal effects for first plot
marg_draw_plot <- marg_draws %>% 
  #create four specific terms for the x-axis
  mutate(interaction = paste0(zm_lake, zm_sample_lag_2)) %>% 
  mutate(interaction = case_when(interaction== "nn" ~ "Uninvaded Before",
                                 interaction == "ny" ~ "Uninvaded After",
                                 interaction == "yn" ~ "Zebra Mussel Before",
                                 interaction == "yy" ~ "Zebra Mussel After",
                                 TRUE ~ NA),
         interaction = factor(interaction, levels = c("Uninvaded Before", "Uninvaded After", "Zebra Mussel Before", "Zebra Mussel After"))) 

#creating data to draw lines
median_lines_plot <- marg_draw_plot %>%
  group_by(interaction, zm_lake) %>%
  summarize(median_hg_ppm = median(hg_ppm), .groups = "drop")  %>% 
  mutate(zm_lake = case_when(zm_lake == "n" ~ "Uninvaded",
                             zm_lake == "y" ~ "Zebra Mussel"))
#creating differences
contrasts_draws <- marg_draws %>% 
  select(-.chain, -.iteration) %>% 
  pivot_wider(names_from = c(zm_lake, zm_sample_lag_2),
              values_from = c(.value, hg_ppm))

diff_of_diff <- contrasts_draws %>% 
  mutate(diff_reference = hg_ppm_n_y - hg_ppm_n_n,
         diff_zm = hg_ppm_y_y - hg_ppm_y_n) %>% 
  select(.draw, diff_reference, diff_zm) %>% 
  mutate(value = diff_zm - diff_reference) %>% 
  select(.draw, value) %>% 
  mutate(zm_lake = "Difference in Change")

diff_lakes <- contrasts_draws %>% 
  mutate(diff_reference = hg_ppm_n_y - hg_ppm_n_n,
         diff_zm = hg_ppm_y_y - hg_ppm_y_n) %>% 
  select(.draw, diff_reference, diff_zm) %>% 
  pivot_longer(cols = c(diff_reference, diff_zm),
               names_to = "zm_lake",
               values_to = "value") %>% 
  mutate(zm_lake = case_when(zm_lake == "diff_zm" ~ "Zebra Mussel",
                             TRUE ~ "Uninvaded"))

diff_plot_data <- bind_rows(diff_of_diff, diff_lakes) %>% 
  mutate(zm_lake = factor(zm_lake, levels = c("Uninvaded", "Zebra Mussel", "Difference in Change")))

####################plots################
#plot of individual groupings with actual value
plot1 <- marg_draw_plot %>%
  ggplot(aes(x = interaction, y = hg_ppm, color = interaction, shape = interaction)) +
  stat_pointinterval(
    .width = c(.66, .95),
    show.legend = F
  )  +
  scale_shape_manual("Sample Invasion",
                     values = c(1, 16, 1, 16)) +
  geom_line(
    data = median_lines_plot,
    aes(x = interaction, y = median_hg_ppm, group = zm_lake),
    position = position_dodge(width = 0.1), # Align lines with intervals
    inherit.aes = FALSE,
    key_glyph = "rect",
    color = c("lightblue", "lightblue", "salmon", "salmon")
  ) +
  ylab("Mercury Concentration (ppm)") +
  xlab("") +
  scale_color_manual("Lake Invasion", 
                     values = c("lightblue", "lightblue", "salmon", "salmon")) +
  theme_minimal() +
  theme(
    legend.position = "bottom",
    panel.grid.major.x = element_blank(),
    axis.text.x = element_blank(),
    axis.title.y = element_text(size = 7)
  )

#plot of difference
plot2 <- diff_plot_data %>% 
  ggplot() +
  stat_pointinterval(aes(x = zm_lake, y = value, color = zm_lake), .width = c(.66, .95)) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  ylab("Difference in Mercury Concentration\nBefore and After (ppm)") +
  xlab("") +
  scale_color_manual(values = c("lightblue", "salmon", "black")) +
  theme_minimal() +
  theme(legend.position = "none",
        panel.grid.major.x = element_blank(),
        axis.text.x = element_blank(),
        axis.title.y = element_text(size = 8)) 

# Combine plots side by side
combined_plot <- plot1 + plot2
combined_plot

#add pike icon
pike_outline <- draw_image("pike_outline.jpg", scale = 0.1, x = -0.35, y = 0.4)

combined_plot_pike <- ggdraw(combined_plot) +
  pike_outline
combined_plot_pike

rm(plot1, plot2)
###################stats##############################################
percent_changes <- contrasts_draws %>% 
  mutate(diff_reference = hg_ppm_n_y - hg_ppm_n_n,
         diff_zm = hg_ppm_y_y - hg_ppm_y_n,
         diff_of_diff = diff_zm - diff_reference,
         percent_change_reference = ((hg_ppm_n_y - hg_ppm_n_n)/ hg_ppm_n_n) *100,
         percent_change_zm = ((hg_ppm_y_y - hg_ppm_y_n)/ hg_ppm_y_n) *100,
         percent_change_diff = percent_change_zm - percent_change_reference) 


percent_changes %>% 
  pivot_longer(cols = starts_with("percent_change"),
               names_to = "metric",
               values_to = "percent_change") %>% 
  ggplot() +
  geom_density(aes(x = percent_change, fill = metric), alpha = 0.5) +
  scale_fill_manual(values = c("gray", "lightblue", "salmon"))

summary_percent_change <- percent_changes %>% 
  select(.draw,
         diff_reference,
         diff_zm,
         diff_of_diff,
         percent_change_reference,
         percent_change_zm,
         percent_change_diff) %>% 
  median_qi() %>% 
  pivot_longer(
    cols = starts_with("diff_") | starts_with("percent_change_"),
    names_to = "item",
    values_to = "value"
  ) %>% 
  mutate(item = case_when(!(str_detect(item, "lower") | str_detect(item, "upper")) ~ paste0(item, ".median"),
                          TRUE ~ item)) %>% 
  separate(item, into = c("metric", "statistic"), sep = "\\.") %>%
  pivot_wider(
    names_from = statistic,
    values_from = value
  )
write_csv(summary_percent_change, "nop_change_summary_stats.csv")


##############length vs ppm & probability of exceed############################
length_ranges <- nop_data %>% 
  summarize(min_length = min(scaled_length),
            max_length = max(scaled_length))

length_seq <- length_ranges %>% 
  rowwise() %>% 
  mutate(scaled_length = list(seq(min_length, max_length, length.out = 100))) %>% 
  unnest(cols = c(scaled_length))
rm(length_ranges)

length.stats <- nop_data %>% 
  summarise(mean.length=mean(lgthin), sd.length=sd(lgthin), min.length=min(lgthin), max.length=max(lgthin))

pred_data <- expand_grid(zm_lake = c("y", "n"),
                         zm_sample_lag_2 = c("y", "n"),
                         scaled_length = length_seq$scaled_length)

prob_exceed <- fit_nop %>% 
  add_predicted_draws(newdata = pred_data, re_formula = NA) %>% 
  mutate(mean_length = length.stats$mean.length,
         sd_length = length.stats$sd.length) %>% 
  mutate(lgthin =(scaled_length*sd_length)+mean_length) %>% 
  mutate(is_above_threshold = .prediction > log(.22)) %>%
  group_by(zm_lake, zm_sample_lag_2, lgthin) %>% 
  summarise(prob = mean(is_above_threshold), .groups = 'drop') %>% 
  mutate(zm_lake = case_when(zm_lake == "y" ~ "Zebra Mussel",
                             zm_lake == "n" ~ "Reference"))

pred_lengths <- fit_nop %>% 
  add_predicted_draws(newdata = pred_data, re_formula = NA) %>% 
  mutate(mean_length = length.stats$mean.length,
         sd_length = length.stats$sd.length) %>% 
  mutate(lgthin =(scaled_length*sd_length)+mean_length) %>% 
  group_by(zm_lake, zm_sample_lag_2, lgthin) %>% 
  summarise(median=median(exp(.prediction)), lci=quantile(exp(.prediction), .025), uci=quantile(exp(.prediction), 0.975)) %>% 
  mutate(smoothed_uci = predict(loess(uci ~ lgthin, span = 0.5)),
         smoothed_lci = predict(loess(lci ~ lgthin, span = 0.5)),
         smoothed_median = predict(loess(median ~ lgthin, span = 0.5))) %>%
  ungroup() %>% 
  mutate(zm_lake = case_when(zm_lake == "y" ~ "Zebra Mussel",
                             zm_lake == "n" ~ "Reference"))

#prob of exceed stats and plot
#15 inch fish
prob_exceed %>% 
  mutate(distance = abs(lgthin - 24)) %>% 
  filter(distance == min(distance)) %>%
  select(zm_lake, zm_sample_lag_2, lgthin, prob, distance) %>% 
  write_csv("nop_prob_exceeding_15_in.csv")

#for each draw from the posterior, we generate a prediction based on length, zm_lake, and zm_sample
#to get the probability of exceeding 0.22 ppm, we ask if the prediction is over 0.22. We then find the average # over vs the total for each length/zm
#the slight dip at large values is a result of random noise in the drawing from the posterior and inconsequential to the result - ex. large lengths have larger variation in preiditon - increasing the chace that at least one value may end up smaller than 0.22ppm
vert_line <- prob_exceed %>% 
  mutate(distance = abs(lgthin - 24)) %>% 
  filter(distance == min(distance))

pike_length_probs <- ggplot() +
  geom_hline(yintercept = 0.5, linetype = "dashed") +
  geom_line(data = prob_exceed, aes(x = lgthin, y = prob, color = zm_sample_lag_2)) + 
  geom_point(data = vert_line, aes(x =lgthin, y = prob, color = zm_sample_lag_2)) +
  geom_line(data = vert_line, aes(x = lgthin, y = prob, group = zm_lake)) +
  facet_wrap(~zm_lake, scales = "free_x") +
  scale_colour_manual(values=c("#00CCCC", "#FF6666"), labels=c("Before", "After")) +
  ylim(c(-0.01,1.01)) +
  xlab("Length (mm)") +
  ylab("Probability of Exceeding 0.22 ppm") +
  theme_bw() +
  theme(strip.background = element_blank(), 
        legend.position = "bottom", 
        legend.title = element_blank(), 
        legend.background = element_blank(), 
        panel.grid = element_blank(), 
        strip.text = element_text(size = 13)) 
pike_length_probs <- ggdraw(pike_length_probs) +
  pike_outline
pike_length_probs
ggsave("nop_baci_prob_exeeding_length.jpg", width = 11, height = 7, dpi = 600, bg = "white")

#length vs ppm plot
pike_length_ppm <- ggplot() +
  facet_wrap(~zm_lake, scales='free') +
  theme_bw() +
  geom_ribbon(data = pred_lengths, aes(x = lgthin, y = median, color = zm_sample_lag_2, ymax = smoothed_uci, ymin = smoothed_lci, fill = zm_sample_lag_2), lwd = 0, alpha = .3) + # alpha is transparency
  geom_line(data = pred_lengths, lwd = 1, aes(x = lgthin, y = median, color = zm_sample_lag_2, lty = zm_sample_lag_2)) + # center line of ribbon
  geom_point(data = nop_data %>% 
               mutate(zm_lake = case_when(zm_lake == "y" ~ "Zebra Mussel",
                             zm_lake == "n" ~ "Reference")), aes(x = lgthin, y = hgppm, color = zm_sample_lag_2), alpha = .2) +
  scale_linetype_manual(values = c(1, 6), labels = c("Before", "After")) + # to tell it which line type you want
  scale_colour_manual(values = c("#00CCCC", "#FF6666"), labels = c("Before", "After")) +
  scale_fill_manual(values = c("#00CCCC", "#FF6666"), labels = c("Before", "After")) +
  ylab("Mercury Concentration (ppm)") +
  xlab("Fish Length (mm)") +
  labs(fill = "Invasion status", lty = "Invasion status", color = "Invasion status", labels = c("Before", "After")) +
  geom_hline(yintercept = 0.22) +
  theme(strip.background = element_blank(), 
        legend.position = "bottom", 
        legend.title = element_blank(), 
        legend.background = element_blank(), 
        panel.grid = element_blank(), 
        strip.text = element_text(size = 13))
pike_length_ppm <- ggdraw(pike_length_ppm) +
  pike_outline
pike_length_ppm
ggsave("nop_length_ppm_invasion.jpg", width = 11, height = 7, dpi = 600)
rm(pred_lengths, pred_data)


  
#############everything below is more exploratory###########################
#first basic output viewing
summary(fit_nop)
plot(fit_nop)
pp_check(fit_nop, ndraws = 50)

#this generates contrasts in the log scale 
contrasts <- contrast(emmeans(fit_nop, ~ zm_lake * zm_sample_lag_2, re_formula = NA, epred = TRUE), 
                      method = "revpairwise", by = "zm_lake")
contrasts
# this gets us the answer in the log scale; such that for each level within zm lake, zm_sample y is "X" units higher/lower than zm_sample n
# If you were to exp() that estimate, then we can say that zm_sample y is "X" TIMES the concentration of zm sample n 

contrasts <- contrast(emmeans(fit_nop, ~ zm_lake * zm_sample_lag_2, re_formula = NA, epred = TRUE, at = list(scaled_length = -1.599011)), 
                      method = "revpairwise", by = "zm_lake")
contrasts
rm(contrasts)

#now lets generate contrasts in the original scale
marg_draws <- emmeans(fit_nop, ~ zm_lake * zm_sample_lag_2, re_fromula = NA, epred = T) %>% 
  gather_emmeans_draws() %>% 
  mutate(hg_ppm = exp(.value))

#code below creates marg draws for a 15 inch fish
#marg_draws <- emmeans(fit_nop, ~ zm_lake * zm_sample_lag_1, re_fromula = NA, epred = T, at = list(scaled_length = -1.599011)) %>% 
#  gather_emmeans_draws() %>% 
#  mutate(hg_ppm = exp(.value))

#average values for zm_lake for before and after 
marg_draws %>% 
  select(zm_lake, zm_sample_lag_2, hg_ppm) %>% 
  group_by(zm_lake, zm_sample_lag_2) %>% 
  median_qi()

# Extract medians for lines
median_lines <- marg_draws %>%
  mutate(zm_sample_lag_2 = case_when(zm_sample_lag_2 == "n" ~ "Before",
                                     TRUE ~ "After"),
         zm_lake = case_when(zm_lake == "y" ~ "Zebra Mussel",
                             TRUE ~ "Uninvaded"),
         zm_sample_lag_2 = factor(zm_sample_lag_2, levels = c("Before", "After"))) %>% 
  group_by(zm_lake, zm_sample_lag_2) %>%
  summarize(median_hg_ppm = median(hg_ppm), .groups = "drop")


# Plot with intervals and median connecting lines
marg_draws %>%
  mutate(zm_sample_lag_2 = case_when(zm_sample_lag_2 == "n" ~ "Before",
                                     TRUE ~ "After"),
         zm_lake = case_when(zm_lake == "y" ~ "Zebra Mussel",
                             TRUE ~ "Uninvaded"),
         zm_sample_lag_2 = factor(zm_sample_lag_2, levels = c("Before", "After"))) %>% 
  ggplot(aes(x = zm_sample_lag_2, y = hg_ppm, color = zm_lake)) +
  stat_pointinterval(
    aes(group = zm_lake),
    .width = c(.66, .95),
    position = position_dodge(width = 0.1), # Prevent interval overlap
    show.legend = F
  ) +
  geom_line(
    data = median_lines,
    aes(x = zm_sample_lag_1, y = median_hg_ppm, group = zm_lake, color = zm_lake),
    position = position_dodge(width = 0.1), # Align lines with intervals
    inherit.aes = FALSE,
    key_glyph = "rect"
  ) +
  ylab("Mercury Concentration (ppm)") +
  xlab("") +
  scale_color_manual("Invasion Status", 
                     values = c("lightblue", "salmon")) +
  theme_minimal() +
  theme(
    legend.position = "bottom",
    panel.grid.major.x = element_blank()
  )

rm(median_lines)


#probability that invaded is larger than invaded 
contrasts_draws %>% 
  mutate(diff_reference = hg_ppm_n_y - hg_ppm_n_n,
         diff_zm = hg_ppm_y_y - hg_ppm_y_n) %>% 
  select(.draw, diff_reference, diff_zm) %>% 
  median_qi(.width = c(.66, .95))

contrasts_draws %>% 
  mutate(diff_reference = hg_ppm_n_y - hg_ppm_n_n,
         diff_zm = hg_ppm_y_y - hg_ppm_y_n) %>% 
  select(.draw, diff_reference, diff_zm) %>% 
  pivot_longer(cols = c(diff_reference, diff_zm),
               names_to = "zm_lake",
               values_to = "diff") %>% 
  mutate(zm_lake = case_when(zm_lake == "diff_zm" ~ "Zebra Mussel",
                             TRUE ~ "Uninvaded")) %>%
  ggplot() + 
  geom_density(aes(diff, fill = zm_lake))

contrasts_draws %>% 
  mutate(diff_reference = hg_ppm_n_y - hg_ppm_n_n,
         diff_zm = hg_ppm_y_y - hg_ppm_y_n) %>% 
  select(.draw, diff_reference, diff_zm) %>% 
  mutate(diff_of_diff = diff_zm - diff_reference) %>% 
  select(.draw, diff_of_diff) %>% 
  ggplot() +
  geom_density(aes(diff_of_diff)) +
  geom_vline(xintercept = 0, linetype = "dashed")

contrasts_draws %>% 
  mutate(diff_reference = hg_ppm_n_y - hg_ppm_n_n,
         diff_zm = hg_ppm_y_y - hg_ppm_y_n) %>% 
  select(.draw, diff_reference, diff_zm) %>% 
  mutate(diff_of_diff = diff_zm - diff_reference) %>% 
  select(.draw, diff_of_diff) %>% 
  summarise(n_larger = sum(diff_of_diff > 0),
            n_total = n(),
            prob = n_larger/n_total,
            median = median(diff_of_diff),
            mean = mean(diff_of_diff),
            ci_95_lower = quantile(diff_of_diff, probs = c(0.025)),
            ci_95_upper = quantile(diff_of_diff, probs = c(0.975)))


#clear objects 
rm(combined_plot, contrasts_draws, fit_nop, marg_draws, pike_outline, diff_lakes, diff_of_diff,
   diff_plot_data, median_lines_plot, marg_draw_plot, percent_changes, summary_percent_change)
```


#Walleye Analysis
*2 lag years for both zm and reference lakes, matching invasion year to the nearest ZM lake for reference lakes
*products are included first in this chunk, all other explorations are below
```{r}
#############create data for plotting###############
#marginal effects based on specific length
length_stats <-  wae_data %>% 
  summarise(mean_length = mean(lgthin),
            sd_length = sd(lgthin))
specific_length_scaled <- (15 - length_stats$mean_length) / length_stats$sd_length

marg_draws <- emmeans(fit_wae, ~ zm_lake * zm_sample_lag_2, 
                      at = list(scaled_length = specific_length_scaled), 
                      re_fromula = NA, 
                      epred = T) %>% 
  gather_emmeans_draws() %>% 
  mutate(hg_ppm = exp(.value))

#working with marginal effects for first plot
marg_draw_plot <- marg_draws %>% 
  #create four specific terms for the x-axis
  mutate(interaction = paste0(zm_lake, zm_sample_lag_2)) %>% 
  mutate(interaction = case_when(interaction== "nn" ~ "Uninvaded Before",
                                 interaction == "ny" ~ "Uninvaded After",
                                 interaction == "yn" ~ "Zebra Mussel Before",
                                 interaction == "yy" ~ "Zebra Mussel After",
                                 TRUE ~ NA),
         interaction = factor(interaction, levels = c("Uninvaded Before", "Uninvaded After", "Zebra Mussel Before", "Zebra Mussel After"))) 

#creating data to draw lines
median_lines_plot <- marg_draw_plot %>%
  group_by(interaction, zm_lake) %>%
  summarize(median_hg_ppm = median(hg_ppm), .groups = "drop")  %>% 
  mutate(zm_lake = case_when(zm_lake == "n" ~ "Uninvaded",
                             zm_lake == "y" ~ "Zebra Mussel"))
#creating differences
contrasts_draws <- marg_draws %>% 
  select(-.chain, -.iteration) %>% 
  pivot_wider(names_from = c(zm_lake, zm_sample_lag_2),
              values_from = c(.value, hg_ppm))

diff_of_diff <- contrasts_draws %>% 
  mutate(diff_reference = hg_ppm_n_y - hg_ppm_n_n,
         diff_zm = hg_ppm_y_y - hg_ppm_y_n) %>% 
  select(.draw, diff_reference, diff_zm) %>% 
  mutate(value = diff_zm - diff_reference) %>% 
  select(.draw, value) %>% 
  mutate(zm_lake = "Difference in Change")

diff_lakes <- contrasts_draws %>% 
  mutate(diff_reference = hg_ppm_n_y - hg_ppm_n_n,
         diff_zm = hg_ppm_y_y - hg_ppm_y_n) %>% 
  select(.draw, diff_reference, diff_zm) %>% 
  pivot_longer(cols = c(diff_reference, diff_zm),
               names_to = "zm_lake",
               values_to = "value") %>% 
  mutate(zm_lake = case_when(zm_lake == "diff_zm" ~ "Zebra Mussel",
                             TRUE ~ "Uninvaded"))

diff_plot_data <- bind_rows(diff_of_diff, diff_lakes) %>% 
  mutate(zm_lake = factor(zm_lake, levels = c("Uninvaded", "Zebra Mussel", "Difference in Change")))

####################plots################
#plot of individual groupings with actual value
plot1 <- marg_draw_plot %>%
  ggplot(aes(x = interaction, y = hg_ppm, color = interaction, shape = interaction)) +
  stat_pointinterval(
    .width = c(.66, .95),
    show.legend = F
  )  +
  scale_shape_manual("Sample Invasion",
                     values = c(1, 16, 1, 16)) +
  geom_line(
    data = median_lines_plot,
    aes(x = interaction, y = median_hg_ppm, group = zm_lake),
    position = position_dodge(width = 0.1), # Align lines with intervals
    inherit.aes = FALSE,
    key_glyph = "rect",
    color = c("lightblue", "lightblue", "salmon", "salmon")
  ) +
  ylab("Mercury Concentration (ppm)") +
  xlab("") +
  scale_color_manual("Lake Invasion", 
                     values = c("lightblue", "lightblue", "salmon", "salmon")) +
  theme_minimal() +
  theme(
    legend.position = "bottom",
    panel.grid.major.x = element_blank(),
    axis.text.x = element_text(angle = 45, hjust = 1, size = 7),
    axis.title.y = element_text(size = 7)
  )


plot2 <- diff_plot_data %>% 
  ggplot() +
  stat_pointinterval(aes(x = zm_lake, y = value, color = zm_lake), .width = c(.66, .95)) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  ylab("Difference in Mercury Concentration\nBefore and After (ppm)") +
  xlab("") +
  scale_color_manual(values = c("lightblue", "salmon", "black")) +
  theme_minimal() +
  theme(legend.position = "none",
        panel.grid.major.x = element_blank(),
        axis.text.x = element_text(angle = 45, hjust = 1, size = 7),
        axis.title.y = element_text(size = 8)) 

# Combine plots side by side
combined_plot <- ggarrange(plot1, plot2, ncol = 2, nrow = 1, common.legend = T, legend = "none") 

walleye_outline <- draw_image("walleye_outline.jpg", scale = 0.1, x = -0.35, y = 0.4)

combined_plot_walleye <- ggdraw(combined_plot) +
  walleye_outline
combined_plot_walleye

rm(plot1, plot2, combined_plot)
###################stats##############################################
percent_changes <- contrasts_draws %>% 
  mutate(diff_reference = hg_ppm_n_y - hg_ppm_n_n,
         diff_zm = hg_ppm_y_y - hg_ppm_y_n,
         diff_of_diff = diff_zm - diff_reference,
         percent_change_reference = ((hg_ppm_n_y - hg_ppm_n_n)/ hg_ppm_n_n) *100,
         percent_change_zm = ((hg_ppm_y_y - hg_ppm_y_n)/ hg_ppm_y_n) *100,
         percent_change_diff = percent_change_zm - percent_change_reference) 


percent_changes %>% 
  pivot_longer(cols = starts_with("percent_change"),
               names_to = "metric",
               values_to = "percent_change") %>% 
  ggplot() +
  geom_density(aes(x = percent_change, fill = metric), alpha = 0.5) +
  scale_fill_manual(values = c("gray", "lightblue", "salmon"))

summary_percent_change <- percent_changes %>% 
  select(.draw,
         diff_reference,
         diff_zm,
         diff_of_diff,
         percent_change_reference,
         percent_change_zm,
         percent_change_diff) %>% 
  median_qi() %>% 
  pivot_longer(
    cols = starts_with("diff_") | starts_with("percent_change_"),
    names_to = "item",
    values_to = "value"
  ) %>% 
  mutate(item = case_when(!(str_detect(item, "lower") | str_detect(item, "upper")) ~ paste0(item, ".median"),
                          TRUE ~ item)) %>% 
  separate(item, into = c("metric", "statistic"), sep = "\\.") %>%
  pivot_wider(
    names_from = statistic,
    values_from = value
  )
write_csv(summary_percent_change, "wae_change_summary_stats.csv")


##############length vs ppm & probability of exceed############################
length_ranges <- wae_data %>% 
  summarize(min_length = min(scaled_length),
            max_length = max(scaled_length))

length_seq <- length_ranges %>% 
  rowwise() %>% 
  mutate(scaled_length = list(seq(min_length, max_length, length.out = 300))) %>% 
  unnest(cols = c(scaled_length))
rm(length_ranges)

length.stats <- wae_data %>% 
  summarise(mean.length=mean(lgthin), sd.length=sd(lgthin), min.length=min(lgthin), max.length=max(lgthin))

pred_data <- expand_grid(zm_lake = c("y", "n"),
                         zm_sample_lag_2 = c("y", "n"),
                         scaled_length = length_seq$scaled_length)

prob_exceed <- fit_wae %>% 
  add_predicted_draws(newdata = pred_data, re_formula = NA) %>% 
  mutate(mean_length = length.stats$mean.length,
         sd_length = length.stats$sd.length) %>% 
  mutate(lgthin =(scaled_length*sd_length)+mean_length) %>% 
  mutate(is_above_threshold = .prediction > log(.22)) %>% 
  group_by(zm_lake, zm_sample_lag_2, scaled_length, lgthin) %>% 
  summarise(prob = mean(is_above_threshold), .groups = 'drop') %>% 
  mutate(zm_lake = case_when(zm_lake == "y" ~ "Zebra Mussel",
                             zm_lake == "n" ~ "Reference"))
#here we use add_predictive_draws to generate predictions from the posterior predictive distribution 
#We see at very long lengths bath and forth from 100-99% 
#this is due to the chance - although unlikely - we did sample some values of long fish below the 0.22 threshold (normal distribution at each length)
#the chances of sampling at least one fish would increase as we increase the number of iterations 

###########exploring 1 - .99 probs at long lengths############################
#why does probability at an increased length ever go down?
# prob_exceed_raw <- fit_wae %>% 
#   add_predicted_draws(newdata = pred_data, re_formula = NA) %>% 
#   mutate(mean_length = length.stats$mean.length,
#          sd_length = length.stats$sd.length) %>% 
#   mutate(lgthin =(scaled_length*sd_length)+mean_length) %>% 
#   mutate(is_above_threshold = .prediction > log(.22))
# 
# weird_draw <- prob_exceed_raw %>% 
#   filter(.draw == "39752")
# 
# weird_draw %>% 
#   mutate(interaction = paste0(zm_lake, zm_sample_lag_2)) %>% 
#   ggplot() +
#   geom_point(aes(scaled_length, .prediction, colour = interaction))
# 
# prob_exceed_raw %>% 
#   filter(scaled_length > 3.21) %>% 
#   summarise(n_below22 = sum(.prediction <= log(0.22)),
#             n = n(),
#             lower95 = quantile(.prediction, probs = .025))
# 
# prob_exceed_raw %>% 
#   filter(scaled_length > 3.21) %>% 
#   glimpse() %>% 
#   ggplot() +
#   geom_histogram(aes(.prediction)) +
#   geom_vline(xintercept = log(.22)) +
#   geom_vline(xintercept = quantile(prob_exceed_raw$.prediction, probs = .025))
# rm(prob_exceed_raw, weird_draw)
##############################################################################

pred_lengths <- fit_wae %>% 
  add_predicted_draws(newdata = pred_data, re_formula = NA) %>% 
  mutate(mean_length = length.stats$mean.length,
         sd_length = length.stats$sd.length) %>% 
  mutate(lgthin =(scaled_length*sd_length)+mean_length) %>% 
  group_by(zm_lake, zm_sample_lag_2, lgthin) %>% 
  summarise(median=median(exp(.prediction)), lci=quantile(exp(.prediction), .025), uci=quantile(exp(.prediction), 0.975)) %>% 
  mutate(smoothed_uci = predict(loess(uci ~ lgthin, span = 0.5)),
         smoothed_lci = predict(loess(lci ~ lgthin, span = 0.5)),
         smoothed_median = predict(loess(median ~ lgthin, span = 0.5))) %>%
  ungroup() %>% 
  mutate(zm_lake = case_when(zm_lake == "y" ~ "Zebra Mussel",
                             zm_lake == "n" ~ "Reference"))

#prob of exceed stats and plot
#15 inch fish
prob_exceed %>% 
  mutate(mean_length = length.stats$mean.length,
         sd_length = length.stats$sd.length) %>% 
  mutate(lgthin =(scaled_length*sd_length)+mean_length) %>% 
  mutate(distance = abs(lgthin - 15)) %>% 
  filter(distance == min(distance)) %>%
  select(zm_lake, zm_sample_lag_2, lgthin, prob, distance) %>% 
  write_csv("wae_prob_exceeding_15_in.csv")

#for each draw from the posterior, we generate a prediction based on length, zm_lake, and zm_sample
#to get the probability of exceeding 0.22 ppm, we ask if the prediction is over 0.22. We then find the average # over vs the total for each length/zm
vert_line <- prob_exceed %>% 
  mutate(distance = abs(lgthin - 15)) %>% 
  filter(distance == min(distance)) 

walleye_length_probs <- ggplot() +
  geom_line(data = prob_exceed, aes(x = lgthin, y = prob, color = zm_sample_lag_2)) + 
  geom_point(data = vert_line, aes(x = lgthin, y = prob, color = zm_sample_lag_2)) +
  geom_line(data = vert_line, aes(x = lgthin, y = prob, group = zm_lake)) +
  facet_wrap(~zm_lake, scales = "free_x") +
  scale_colour_manual(values=c("#00CCCC", "#FF6666"), labels=c("Before", "After")) +
  ylim(c(-0.05,1.05)) +
  xlab("Length (in)") +
  ylab("Probability of Exceeding 0.22 ppm") +
  theme_bw() +
  theme(strip.background = element_blank(), 
        legend.position = "bottom", 
        legend.title = element_blank(), 
        legend.background = element_blank(), 
        panel.grid = element_blank(), 
        strip.text = element_text(size = 13))
walleye_length_probs <- ggdraw(walleye_length_probs) +
  walleye_outline
walleye_length_probs
ggsave("wae_baci_prob_exeeding_length.jpg", width = 11, height = 7, dpi = 600, bg = "white")

#length vs ppm plot
walleye_length_ppm <- ggplot() +
  facet_wrap(~zm_lake, scales='free') +
  theme_bw() +
  geom_ribbon(data = pred_lengths, aes(x = lgthin, y = median, color = zm_sample_lag_2, ymax = smoothed_uci, ymin = smoothed_lci, fill = zm_sample_lag_2), lwd = 0, alpha = .3) + # alpha is transparency
  geom_line(data = pred_lengths, lwd = 1, aes(x = lgthin, y = median, color = zm_sample_lag_2, lty = zm_sample_lag_2)) + # center line of ribbon
  geom_point(data = wae_data %>% 
               mutate(zm_lake = case_when(zm_lake == "y" ~ "Zebra Mussel",
                             zm_lake == "n" ~ "Reference")), aes(x = lgthin, y = hgppm, color = zm_sample_lag_2), alpha = .2) +
  scale_linetype_manual(values = c(1, 6), labels = c("Before", "After")) + # to tell it which line type you want
  scale_colour_manual(values = c("#00CCCC", "#FF6666"), labels = c("Before", "After")) +
  scale_fill_manual(values = c("#00CCCC", "#FF6666"), labels = c("Before", "After")) +
  ylab("Mercury Concentration (ppm)") +
  xlab("Fish Length (in)") +
  labs(fill = "Invasion status", lty = "Invasion status", color = "Invasion status", labels = c("Before", "After")) +
  geom_hline(yintercept = 0.22) +
  theme(strip.background = element_blank(), 
        legend.position = "bottom", 
        legend.title = element_blank(), 
        legend.background = element_blank(), 
        panel.grid = element_blank(), 
        strip.text = element_text(size = 13))
walleye_length_ppm <- ggdraw(walleye_length_ppm) +
  walleye_outline
walleye_length_ppm
ggsave("wae_length_ppm_invasion.jpg", width = 11, height = 7, dpi = 600)
rm(pred_lengths, pred_data)


  
#############everything below is more exploratory###########################
#first basic output viewing
summary(fit_wae)
plot(fit_wae)
pp_check(fit_wae, ndraws = 50)

#this generates contrasts in the log scale 
contrasts <- contrast(emmeans(fit_wae, ~ zm_lake * zm_sample_lag_2, re_formula = NA, epred = TRUE), 
                      method = "revpairwise", by = "zm_lake")
contrasts
# this gets us the answer in the log scale; such that for each level within zm lake, zm_sample y is "X" units higher/lower than zm_sample n
# If you were to exp() that estimate, then we can say that zm_sample y is "X" TIMES the concentration of zm sample n 

contrasts <- contrast(emmeans(fit_wae, ~ zm_lake * zm_sample_lag_2, re_formula = NA, epred = TRUE, at = list(scaled_length = -1.599011)), 
                      method = "revpairwise", by = "zm_lake")
contrasts
rm(contrasts)

#now lets generate contrasts in the original scale
marg_draws <- emmeans(fit_wae, ~ zm_lake * zm_sample_lag_2, re_fromula = NA, epred = T) %>% 
  gather_emmeans_draws() %>% 
  mutate(hg_ppm = exp(.value))

#code below creates marg draws for a 15 inch fish
#marg_draws <- emmeans(fit_nop, ~ zm_lake * zm_sample_lag_1, re_fromula = NA, epred = T, at = list(scaled_length = -1.599011)) %>% 
#  gather_emmeans_draws() %>% 
#  mutate(hg_ppm = exp(.value))

#average values for zm_lake for before and after 
marg_draws %>% 
  select(zm_lake, zm_sample_lag_2, hg_ppm) %>% 
  group_by(zm_lake, zm_sample_lag_2) %>% 
  median_qi()

# Extract medians for lines
median_lines <- marg_draws %>%
  mutate(zm_sample_lag_2 = case_when(zm_sample_lag_2 == "n" ~ "Before",
                                     TRUE ~ "After"),
         zm_lake = case_when(zm_lake == "y" ~ "Zebra Mussel",
                             TRUE ~ "Uninvaded"),
         zm_sample_lag_2 = factor(zm_sample_lag_2, levels = c("Before", "After"))) %>% 
  group_by(zm_lake, zm_sample_lag_2) %>%
  summarize(median_hg_ppm = median(hg_ppm), .groups = "drop")


# Plot with intervals and median connecting lines
marg_draws %>%
  mutate(zm_sample_lag_2 = case_when(zm_sample_lag_2 == "n" ~ "Before",
                                     TRUE ~ "After"),
         zm_lake = case_when(zm_lake == "y" ~ "Zebra Mussel",
                             TRUE ~ "Uninvaded"),
         zm_sample_lag_2 = factor(zm_sample_lag_2, levels = c("Before", "After"))) %>% 
  ggplot(aes(x = zm_sample_lag_2, y = hg_ppm, color = zm_lake)) +
  stat_pointinterval(
    aes(group = zm_lake),
    .width = c(.66, .95),
    position = position_dodge(width = 0.1), # Prevent interval overlap
    show.legend = F
  ) +
  geom_line(
    data = median_lines,
    aes(x = zm_sample_lag_1, y = median_hg_ppm, group = zm_lake, color = zm_lake),
    position = position_dodge(width = 0.1), # Align lines with intervals
    inherit.aes = FALSE,
    key_glyph = "rect"
  ) +
  ylab("Mercury Concentration (ppm)") +
  xlab("") +
  scale_color_manual("Invasion Status", 
                     values = c("lightblue", "salmon")) +
  theme_minimal() +
  theme(
    legend.position = "bottom",
    panel.grid.major.x = element_blank()
  )

rm(median_lines)


#probability that invaded is larger than invaded 
contrasts_draws %>% 
  mutate(diff_reference = hg_ppm_n_y - hg_ppm_n_n,
         diff_zm = hg_ppm_y_y - hg_ppm_y_n) %>% 
  select(.draw, diff_reference, diff_zm) %>% 
  median_qi(.width = c(.66, .95))

contrasts_draws %>% 
  mutate(diff_reference = hg_ppm_n_y - hg_ppm_n_n,
         diff_zm = hg_ppm_y_y - hg_ppm_y_n) %>% 
  select(.draw, diff_reference, diff_zm) %>% 
  pivot_longer(cols = c(diff_reference, diff_zm),
               names_to = "zm_lake",
               values_to = "diff") %>% 
  mutate(zm_lake = case_when(zm_lake == "diff_zm" ~ "Zebra Mussel",
                             TRUE ~ "Uninvaded")) %>%
  ggplot() + 
  geom_density(aes(diff, fill = zm_lake))

contrasts_draws %>% 
  mutate(diff_reference = hg_ppm_n_y - hg_ppm_n_n,
         diff_zm = hg_ppm_y_y - hg_ppm_y_n) %>% 
  select(.draw, diff_reference, diff_zm) %>% 
  mutate(diff_of_diff = diff_zm - diff_reference) %>% 
  select(.draw, diff_of_diff) %>% 
  ggplot() +
  geom_density(aes(diff_of_diff)) +
  geom_vline(xintercept = 0, linetype = "dashed")

contrasts_draws %>% 
  mutate(diff_reference = hg_ppm_n_y - hg_ppm_n_n,
         diff_zm = hg_ppm_y_y - hg_ppm_y_n) %>% 
  select(.draw, diff_reference, diff_zm) %>% 
  mutate(diff_of_diff = diff_zm - diff_reference) %>% 
  select(.draw, diff_of_diff) %>% 
  summarise(n_larger = sum(diff_of_diff > 0),
            n_total = n(),
            prob = n_larger/n_total,
            median = median(diff_of_diff),
            mean = mean(diff_of_diff),
            ci_95_lower = quantile(diff_of_diff, probs = c(0.025)),
            ci_95_upper = quantile(diff_of_diff, probs = c(0.975)))


#clear objects 
rm(contrasts_draws, fit_wae, marg_draws, diff_lakes, diff_of_diff,
   diff_plot_data, median_lines_plot, percent_changes)
```


#Combining walleye and pike plots
```{r}
#BACI Effect
species_plot <- combined_plot_pike / combined_plot_walleye +
  plot_layout(height = c(1,1))
species_plot

ggsave(plot = species_plot, "baci_wae_nop_marginal_effects.jpg", height = 5, width = 7, dpi = 600, bg = "white")
rm(species_plot)

#Length vs. PPM
ppm_length <- pike_length_ppm / walleye_length_ppm +
  plot_layout(height = c(1,1))
ppm_length
ggsave(plot = ppm_length, "length_ppm_wae_nop.jpg", height = 11, width = 7, dpi = 600, bg = "white")

#Probs with length
probs_length <- pike_length_probs / walleye_length_probs +
  plot_layout(height = c(1,1))
probs_length
ggsave(plot = probs_length, "length_probs_wae_nop.jpg", height = 5, width = 7, dpi = 600, bg = "white")

```

# Exploring Random Effects - dow
```{r}
#walleye - this is code to take the top 5, bottom 5, and mille lacs
ranef_dow <- fit_wae %>% 
  spread_draws(r_dow[dow, Intercept]) %>% 
  group_by(dow) %>% 
  summarise(median = median(r_dow)) %>% 
  mutate(dow = sprintf("%08d", as.numeric(dow)))

lake_names <- wae_data %>% 
  distinct(dow, .keep_all = T) %>% 
  select(dow, waterway)

ranef_dow_names <- ranef_dow %>% 
  left_join(lake_names) %>% 
  arrange(desc(median))

mille_lacs <- ranef_dow_names %>% 
  filter(dow == "48000200")

top_bottom_dow <- bind_rows(
  head(ranef_dow_names, 5),
  tail(ranef_dow_names, 5),
  mille_lacs
)

#plotting 
ranef_dow_names %>% 
  ggplot() +
  geom_density(aes(median)) 

ranef_dow_names %>% 
  ggplot() +
  geom_histogram(aes(median), fill = "grey") +  # Density plot
  geom_point(
    data = mille_lacs, 
    aes(x = median, y = 0),  # Place the point on the x-axis
    color = "red", 
    size = 3
  ) +
  labs( y = "",
        x = ""
  ) +
  theme_minimal()
ggsave("walleye_random_effect_dow.jpg", height = 5, width = 5, dpi = 600, background = "white")

rm(ranef_dow, lake_names, ranef_dow_names, mille_lacs, top_bottom_dow)
```

# Exploring random effects - year
```{r}
walleye_outline <- draw_image("walleye_outline.jpg", scale = 0.1, x = -0.35, y = 0.4)
pike_outline <- draw_image("pike_outline.jpg", scale = 0.1, x = -0.35, y = 0.4)

#walleye
ranef_year_wae_raw <- fit_wae %>% 
  spread_draws(r_yearcoll[yearcoll, Intercept])

ranef_year_wae <- ranef_year_wae_raw %>% 
  ggplot(aes(x = yearcoll, y = r_yearcoll)) +
  stat_pointinterval(
    .width = c(.66, .95),
    position = position_dodge(width = 0.1)
  ) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  scale_y_continuous(limits = c(-.3, .3)) +
  labs(x = "") +
  theme_minimal()

ranef_year_wae <- ggdraw(ranef_year_wae) + walleye_outline
ranef_year_wae

#pike
ranef_year_nop_raw <- fit_nop %>% 
  spread_draws(r_yearcoll[yearcoll, Intercept])

ranef_year_nop <- ranef_year_nop_raw %>% 
  ggplot(aes(x = yearcoll, y = r_yearcoll)) +
  stat_pointinterval(
    .width = c(.66, .95),
    position = position_dodge(width = 0.1)
  ) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  scale_y_continuous(limits =  c(-.3, .3)) +
  labs(x = "") +
  theme_minimal()

ranef_year_nop <- ggdraw(ranef_year_nop) + pike_outline
ranef_year_nop

#combining plots
combined_rand_eff_year <- ranef_year_nop / ranef_year_wae
combined_rand_eff_year
ggsave("rand_year_effect.jpg", combined_rand_eff_year, height = 5, width = 7, dpi = 600, background = "white")

rm(ranef_year_wae_raw, ranef_year_nop_raw, ranef_year_wae, ranef_year_nop, walleye_outline, pike_outline, combined_rand_eff_year)
```

##############################################################################

# Old code 
```{r}
#this section of code was initally used to filter for baci data but was replaced with a function
#############Data for Analysis###############
#walleye zebra mussel data 
wae_zm_lakes <- hg.model %>% 
  filter(spec == "WAE") %>% 
  filter(yearcoll >= 2000) %>% 
  filter(zm_lake == "y") %>% 
  distinct(dow, zm_sample) %>% 
  group_by(dow) %>% 
  count() %>% 
  filter(n >1)
#this code chunk 1.) filters for walleye 2.) filters for years 2000-most recent 3.) filters for lakes invaded by zebra mussels 4.) finds the unique combinations for lake id and hg samples collected during zm invasion 5.) counts how many times a lake shows up - if it shows up 2x then it has both y and n for zm invasion samples 6.) filters for lakes that only have zm invasion 

wae_zm_fish <- hg.model %>% 
  filter(yearcoll >= 2000) %>%
  filter(spec == "WAE") %>% 
  filter(dow %in% c(wae_zm_lakes$dow))

#walleye reference lake 
wae_ref_lakes <- hg.model %>% 
  filter(spec == "WAE") %>% 
  filter(yearcoll >= 2000) %>% 
  filter(zm_lake == "n") %>% 
  #creating pseudo invasion based on middle year of the study
  mutate(zm_sample = case_when(yearcoll >= 2011 ~ "y",
                               yearcoll <= 2010 ~ "n")) %>% 
  distinct(dow, zm_sample) %>% 
  group_by(dow) %>% 
  count() %>% 
  filter(n >1)

wae_ref_fish <- hg.model %>% 
  filter(yearcoll >= 2000) %>%
  filter(spec == "WAE") %>% 
  filter(dow %in% c(wae_ref_lakes$dow)) %>% 
  mutate(zm_sample = case_when(yearcoll >= 2011 ~ "y",
                               yearcoll <= 2010 ~ "n"))

#######################northern pike#######################################
#pike zebra mussel data 
nop_zm_lakes <- hg.model %>% 
  filter(spec == "NOP") %>% 
  filter(yearcoll >= 2000) %>% 
  filter(zm_lake == "y") %>% 
  distinct(dow, zm_sample) %>% 
  group_by(dow) %>% 
  count() %>% 
  filter(n >1)
#this code chunk 1.) filters for pike 2.) filters for years 2000-most recent 3.) filters for lakes invaded by zebra mussels 4.) finds the unique combinations for lake id and hg samples collected during zm invasion 5.) counts how many times a lake shows up - if it shows up 2x then it has both y and n for zm invasion samples 6.) filters for lakes that only have zm invasion 

nop_zm_fish <- hg.model %>% 
  filter(yearcoll >= 2000) %>%
  filter(spec == "NOP") %>% 
  filter(dow %in% c(nop_zm_lakes$dow))

#walleye reference lake 
nop_ref_lakes <- hg.model %>% 
  filter(spec == "NOP") %>% 
  filter(yearcoll >= 2000) %>% 
  filter(zm_lake == "n") %>% 
  #creating pseudo invasion based on middle year of the study
  mutate(zm_sample = case_when(yearcoll >= 2011 ~ "y",
                               yearcoll <= 2010 ~ "n")) %>% 
  distinct(dow, zm_sample) %>% 
  group_by(dow) %>% 
  count() %>% 
  filter(n >1)

nop_ref_fish <- hg.model %>% 
  filter(yearcoll >= 2000) %>% 
  filter(spec == "NOP") %>% 
  filter(dow %in% c(nop_ref_lakes$dow))  %>% 
  mutate(zm_sample = case_when(yearcoll >= 2011 ~ "y",
                               yearcoll <= 2010 ~ "n"))

##############combined####################
baci_data <- bind_rows(nop_ref_fish, nop_zm_fish, wae_ref_fish, wae_zm_fish)
rm(nop_ref_fish, nop_zm_fish, wae_ref_fish, wae_zm_fish,
   nop_ref_lakes, nop_zm_lakes, wae_ref_lakes, wae_zm_lakes)

baci_data <- baci_data %>% 
  group_by(spec) %>% 
  mutate(scaled.length = c(scale(lgthin)))

###########quick QC##################################
baci_data %>% 
  group_by(yearcoll) %>% 
  count() %>% 
  print(n = nrow(.))

baci_data %>% 
  group_by(zm_lake, zm_sample) %>% 
  count()
###############################################################################

hg_all %>% 
  group_by(SPEC) %>% 
  count() %>% 
  print(n = nrow(.))

hg_all %>% 
  filter(str_detect(WATERWAY, "OOL")) %>% 
  distinct(WATERWAY) %>% 
  print(n = nrow(.))

hg_all %>% 
  filter(WATERWAY == "MISSISSIPPI R.") %>% 
  distinct(WATERWAY, LOCATION) %>% 
  print(n = nrow(.))

hg_all %>% 
  filter(str_detect(LOCATION, "OOL 3") | str_detect(LOCATION, "ool 3")) %>% 
  group_by(LOCATION, SPEC) %>% 
  count() %>% 
  print(n = nrow(.))

hg_all %>% 
  filter(str_detect(LOCATION, "OOL 3") | str_detect(LOCATION, "ool 3")) %>%
  group_by(SPEC) %>% 
  count()

hg_all %>% 
  filter(str_detect(LOCATION, "OOL 3") | str_detect(LOCATION, "ool 3")) %>%
  group_by(SPEC, YEARCOLL) %>% 
  count() %>% 
  arrange(YEARCOLL) %>% 
  print(n = nrow(.))

matching <- read_rds("baci_update_wae_zm_sample.rds")
plot(conditional_effects(matching))

marg_draws <- emmeans(matching, ~ zm_lake * zm_sample, re_formula = NA, epred = T) %>% 
  gather_emmeans_draws() %>% 
  mutate(hg_ppm = exp(.value))

contrasts_draws <- marg_draws %>% 
  select(-.chain, -.iteration) %>% 
  pivot_wider(names_from = c(zm_lake, zm_sample),
              values_from = c(.value, hg_ppm))

contrasts_draws %>% 
  mutate(diff_reference = hg_ppm_n_y - hg_ppm_n_n,
         diff_zm = hg_ppm_y_y - hg_ppm_y_n) %>% 
  select(.draw, diff_reference, diff_zm) %>% 
  median_qi(.width = c(.66, .95))

contrasts_draws %>% 
  mutate(diff_reference = hg_ppm_n_y - hg_ppm_n_n,
         diff_zm = hg_ppm_y_y - hg_ppm_y_n) %>% 
  select(.draw, diff_reference, diff_zm) %>% 
  pivot_longer(cols = c(diff_reference, diff_zm),
               names_to = "zm_lake",
               values_to = "diff") %>% 
  mutate(zm_lake = case_when(zm_lake == "diff_zm" ~ "Zebra Mussel",
                             TRUE ~ "Uninvaded")) %>% 
  ggplot() +
  stat_pointinterval(aes(x = zm_lake, y = diff, color = zm_lake), .width = c(.66, .95)) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  ylab("Difference in Mercury\nConcentrations Before and After (ppm)") +
  xlab("") +
  scale_color_manual(values = c("lightblue", "salmon")) +
  theme_minimal() +
  theme(legend.position = "none",
        panel.grid.major.x = element_blank()) 

contrasts_draws %>% 
  mutate(diff_reference = hg_ppm_n_y - hg_ppm_n_n,
         diff_zm = hg_ppm_y_y - hg_ppm_y_n) %>% 
  select(.draw, diff_reference, diff_zm) %>% 
  mutate(diff_of_diff = diff_zm - diff_reference) %>% 
  select(.draw, diff_of_diff) %>% 
  ggplot() +
  stat_pointinterval(aes(y = diff_of_diff), .width = c(.66, .95)) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  ylab("Difference of Difference (ppm)") +
  xlab("") +
  theme_minimal() +
  theme(panel.grid.major.x = element_blank(),
        axis.text.x = element_blank())

########old filter function based on median year##########################
create_species_data <- function(species, data) {
  # Filter zebra mussel lakes
  zm_lakes <- data %>% 
    filter(spec == species) %>% 
    filter(yearcoll >= 2000) %>% 
    filter(zm_lake == "y") %>% 
    distinct(dow, zm_sample_lag_1) %>% 
    group_by(dow) %>% 
    count() %>% 
    filter(n > 1)

  zm_fish <- data %>% 
    filter(yearcoll >= 2000) %>%
    filter(spec == species) %>% 
    filter(dow %in% c(zm_lakes$dow))

  # Filter reference lakes
  ref_lakes <- data %>% 
    filter(spec == species) %>% 
    filter(yearcoll >= 2000) %>% 
    filter(zm_lake == "n") %>% 
    mutate(zm_sample_lag_1 = case_when(
      yearcoll >= 2011 ~ "y",
      yearcoll <= 2010 ~ "n"
    )) %>% 
    distinct(dow, zm_sample_lag_1) %>% 
    group_by(dow) %>% 
    count() %>% 
    filter(n > 1)

  ref_fish <- data %>% 
    filter(yearcoll >= 2000) %>% 
    filter(spec == species) %>% 
    filter(dow %in% c(ref_lakes$dow)) %>% 
    mutate(zm_sample_lag_1 = case_when(
      yearcoll >= 2011 ~ "y",
      yearcoll <= 2010 ~ "n"
    ))

  # Combine zebra mussel and reference data
  species_data <- bind_rows(ref_fish, zm_fish)
    

  # Scale length
  species_data <- species_data %>% 
    mutate(scaled_length = c(scale(lgthin)))

  return(species_data)
}

#quick look at a map for one of the lag years
#get data
map_data <- bind_rows(NOP_zm_sample_lag_1,
                     WAE_zm_sample_lag_1)
glimpse(map_data)

#make sf objects
lakes_sf <- st_as_sf(map_data, coords = c("centroid_lon", "centroid_lat"), crs = 4326)

mn_map <- states(cb = T) %>% 
  filter(STUSPS == "MN")

minnesota_sf <- st_as_sf(mn_map)
rm(mn_map)

#summarize some data
lake_summary <- map_data %>%
  group_by(dow, spec) %>%
  summarize(
    distinct_years = n_distinct(yearcoll),
    total_samples = n()
  )


spec <- map_data %>% 
  distinct(dow, spec) %>% 
  pivot_wider(names_from = spec,
              values_from = spec,
              values_fn = length,
              values_fill = list(spec = NA)) %>% 
  mutate(species = case_when(NOP == "1" & WAE == "1" ~ "Walleye & Northern Pike",
                          NOP == "1" & is.na(WAE) ~ "Northern Pike",
                          TRUE ~ "Walleye"))

lakes_sf <- lakes_sf %>%
  left_join(lake_summary, by = c("dow", "spec")) %>% 
  left_join(spec) %>% 
  mutate(species_simp = species) %>% 
  mutate(species = case_when(species == "Walleye & Northern Pike" & spec == "WAE" ~ "Both - Walleye",
                             species == "Walleye & Northern Pike" & spec == "NOP" ~ "Both - Northern Pike",
                             species == "Northern Pike" ~ "Northern Pike",
                             species == "Walleye" ~ "Walleye"))

#simple map showing lake locations by species 
ggplot() +
  # Plot Minnesota state
  geom_sf(data = minnesota_sf, fill = "white", color = "black") +
  
  # Plot lakes with centroids
  geom_sf(data = lakes_sf, 
          aes(color = zm_lake, 
              shape = species_simp),
          size = 3) +
  scale_color_manual("Invasion Status of Lake", values = c("lightblue", "salmon"), labels = c("Uninvaded", "Zebra Mussel")) +
  scale_shape_manual("Species Sampled", values = c(1, 16, 17)) +
  # Remove gridlines and set white background
  theme_minimal() +
  theme(panel.background = element_rect(fill = "white", color = NA),
        panel.grid = element_blank(),
        legend.position.inside = c(.79, .4),
         legend.box.background = element_rect(color = "black", size = 0.5),
        legend.key.size = unit(.2, "cm")) 
ggsave("BACI_lakes_map.jpg", height = 7, width = 7, dpi = 600, bg = "white")

rm(lake_summary, lakes_sf, map_data, minnesota_sf, spec)

#get data
map_data <- bind_rows(nop_data,
                     wae_data) %>% 
  mutate(centroid_lat = case_when(is.na(centroid_lat) ~ lake_lat_decdeg,
                                  TRUE ~ centroid_lat),
         centroid_lon = case_when(is.na(centroid_lon) ~ lake_lon_decdeg,
                                  TRUE ~ centroid_lon)) 
glimpse(map_data)

#make sf objects
lakes_sf <- st_as_sf(map_data, coords = c("centroid_lon", "centroid_lat"), crs = 4326)

mn_map <- states(cb = T) %>% 
  filter(STUSPS == "MN")

minnesota_sf <- st_as_sf(mn_map)
rm(mn_map)

#summarize some data
lake_summary <- map_data %>%
  group_by(dow, spec) %>%
  summarize(
    distinct_years = n_distinct(yearcoll),
    total_samples = n()
  )


spec <- map_data %>% 
  distinct(dow, spec) %>% 
  pivot_wider(names_from = spec,
              values_from = spec,
              values_fn = length,
              values_fill = list(spec = NA)) %>% 
  mutate(species = case_when(NOP == "1" & WAE == "1" ~ "Walleye & Northern Pike",
                          NOP == "1" & is.na(WAE) ~ "Northern Pike",
                          TRUE ~ "Walleye"))

lakes_sf <- lakes_sf %>%
  left_join(lake_summary, by = c("dow", "spec")) %>% 
  left_join(spec) %>% 
  mutate(species_simp = species) %>% 
  mutate(species = case_when(species == "Walleye & Northern Pike" & spec == "WAE" ~ "Both - Walleye",
                             species == "Walleye & Northern Pike" & spec == "NOP" ~ "Both - Northern Pike",
                             species == "Northern Pike" ~ "Northern Pike",
                             species == "Walleye" ~ "Walleye"))

#simple map showing lake locations by species 
ggplot() +
  # Plot Minnesota state
  geom_sf(data = minnesota_sf, fill = "white", color = "black") +
  
  # Plot lakes with centroids
  geom_sf(data = lakes_sf, 
          aes(color = zm_lake, 
              shape = species_simp),
          size = 3) +
  scale_color_manual("Invasion Status of Lake", values = c("lightblue", "salmon"), labels = c("Uninvaded", "Zebra Mussel")) +
  scale_shape_manual("Species Sampled", values = c(1, 16, 17)) +
  # Remove gridlines and set white background
  theme_minimal() +
  theme(panel.background = element_rect(fill = "white", color = NA),
        panel.grid = element_blank(),
        legend.position = c(.79, .4),
         legend.box.background = element_rect(color = "black", size = 0.5),
        legend.key.size = unit(.2, "cm")) 
ggsave("BACI_lakes_map.jpg", height = 7, width = 7, dpi = 600, bg = "white")



#make map - this make attempts to add sample size info - think it would be too much for a publication
ggplot() +
  # Plot Minnesota state
  geom_sf(data = minnesota_sf, fill = "white", color = "black") +
  
  # Plot lakes with centroids
  geom_sf(data = lakes_sf, 
          aes(color = zm_lake, 
              size = distinct_years, 
              shape = species)) +
  
  # Adjust size scale
  scale_size_continuous(range = c(3, 6), guide = "none") +
  
  # Customize shapes
  scale_shape_manual(values = c(1, 19, 8, 4)) +
  
  scale_color_manual("Invasion Status of Lake", values = c("lightblue", "salmon"), labels = c("Uninvaded", "Zebra Mussel")) +
  
  # Remove gridlines and set white background
  theme_minimal() +
  theme(panel.background = element_rect(fill = "white", color = NA),
        panel.grid = element_blank(),
        legend.position = "bottom",
        legend.direction = "vertical") +
  
  # Add title and labels
  labs(shape = "Species")
ggsave("BACI_lakes_map_complex.jpg", height = 5, width = 5, dpi = 600, bg = "white")
  
  
rm(lake_summary, lake_sf, map_data, minnesota_sf, spec)
```

